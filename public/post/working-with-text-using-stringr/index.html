<!DOCTYPE html>
<html lang="en" data-theme=""><head>
    <title> Steve Pederson | Working with Text using stringr </title>

    
    <meta charset="utf-8"><meta name="generator" content="Hugo 0.75.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
    <meta name="description" content="Dame Roma Mitchell Cancer Research Laboratories">
    
    <link rel="stylesheet"
          href="/css/style.min.8a453d1607c6b0bf76199a2e49154f18557cb8cf4cf667530f5ca9bac2cea239.css"
          integrity="sha256-ikU9FgfGsL92GZouSRVPGFV8uM9M9mdTD1ypusLOojk="
          crossorigin="anonymous"
          type="text/css"><link href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet"
          integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

    
    <link rel="shortcut icon" href="/favicons/favicon.ico" type="image/x-icon">
    <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">

    <link rel="canonical" href="/post/working-with-text-using-stringr/">

    
    
    
    
    <script type="text/javascript"
            src="/js/anatole-header.min.e782db136ec18d105a4552702eac49f4620d6867da3fbf808bd53e806c96be6e.js"
            integrity="sha256-54LbE27BjRBaRVJwLqxJ9GINaGfaP7&#43;Ai9U&#43;gGyWvm4="
            crossorigin="anonymous"></script>
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Working with Text using stringr"/>
<meta name="twitter:description" content="Introduction Key Concepts Working with text is one of the most common processes in R and we often take it for granted."/>

</head>
<body><div class="sidebar animated fadeInDown">
    <div class="logo-title">
        <div class="title">
            <img src="/images/sp.jpg" alt="profile picture">
            <h3 title=""><a href="/">Bioinformatics Training</a></h3>
            <div class="description">
                <p>Dame Roma Mitchell Cancer Research Laboratories</p>
            </div>
        </div>
    </div>
    <ul class="social-links">
        
            <li>
                <a href="https://www.linkedin.com/in/stephen-pederson-06ba4914/" rel="me" aria-label="Linkedin">
                    <i class="fa fa-2x fa-linkedin" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://twitter.com/StevePederson8" rel="me" aria-label="Twitter">
                    <i class="fa fa-2x fa-twitter" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="https://github.com/steveped" rel="me" aria-label="GitHub">
                    <i class="fa fa-2x fa-github" aria-hidden="true"></i>
                </a>
            </li>
        
            <li>
                <a href="mailto:stephen.pederson@adelaide.edu.au" rel="me" aria-label="e-mail">
                    <i class="fa fa-2x fa-envelope" aria-hidden="true"></i>
                </a>
            </li>
        
    </ul>
    <div class="footer">
        <div class="by_farbox">&copy; Steve Pederson 2020 </div>
    </div>
</div>
<div class="main">
    <div class="page-top animated fadeInDown">
    <a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
    </a>
    <ul class="nav" id="navMenu">
        
        
            
            <li><a 
                   href="/"
                        
                   title="">Home</a></li>
        
            
            <li><a 
                   href="/post/"
                        
                   title="">Posts</a></li>
        
            
            <li><a 
                   href="/about/"
                        
                   title="">About</a></li>
        
        
        <li class="theme-switch-item">
            <a class="theme-switch" title="Switch Theme">
                <i class="fa fa-adjust fa-fw" aria-hidden="true"></i>
            </a>
        </li>
    </ul>
</div>

    <div class="autopagerize_page_element">
        <div class="content">
    <div class="post animated fadeInDown">
        <div class="post-content">

            <div class="post-title">
                <h3>Working with Text using stringr</h3>
                
                    <div class="info">
                        <em class="fa fa-sun-o"></em>
                        <span class="date">Mon, Sep 28, 2020</span>
                        <em class="fa fa-clock-o"></em>
                        <span class="reading-time">20-minute read</span>
                    </div>
                
            </div>

            


<div id="introduction" class="section level1">
<h1>Introduction</h1>
<div id="key-concepts" class="section level2">
<h2>Key Concepts</h2>
<p>Working with text is one of the most common processes in R and we often take it for granted.
Today we’ll look at a few important concepts using the package <code>stringr</code>.
The key outcomes will be a better understanding of:</p>
<ul>
<li>Pattern Matching using <em>regular expressions</em></li>
<li>Introduction to <em>categorical variables</em>, known in R as <code>factors</code></li>
<li>Learning to build code that is robust to changes in your data</li>
</ul>
</div>
<div id="setup-for-today" class="section level2">
<h2>Setup for Today</h2>
<p>To start today, let’s return to the same <code>R Project</code> as last week.
This should have been called <code>Improving-R</code> and if everything was done correctly last week, you’ll be able to see this name listed in the drop-down R Project menu in the top-right corner of R Studio.
Just click on the name and you’ll be taken to the correct folder and will be ready to go.
<strong>If you missed last week</strong>, please head to the <a href="https://drmcrl-bioinformatics-training.netlify.app/post/improving-your-data-analysis-in-r/#r-projects">setup section</a> and make sure you have:</p>
<ol style="list-style-type: decimal">
<li>An R Project with the name <code>Improving-R</code>, and</li>
<li>The data file <a href="https://raw.githubusercontent.com/UofABioinformaticsHub/Spring_Into_Bioinformatics/master/Day_2/data/2_alignedData/featureCounts/counts.out">counts.out</a> saved in the folder <code>data</code>.</li>
</ol>
<p>Once you are in the <code>Improving-R</code> R Project, create a new R Markdown file (<code>File &gt; New File &gt; R Markdown</code>).
Set the title to be “Working with Text” and add your own name etc.
Save this as <code>TextManipulation.Rmd</code>, or some other suitable name.</p>
<p>Find the first chunk (named <code>setup</code>) and:</p>
<ol style="list-style-type: decimal">
<li>Delete everything below the <code>setup</code> chunk</li>
<li>Add <code>message = FALSE</code> inside the function <code>knitr::opts_chunk$set()</code></li>
<li>Create a new chunk directly below the first one called <code>packages</code></li>
<li>Inside the chunk <code>packages</code> add <code>library(tidyverse)</code>.</li>
</ol>
<p>Now compile the document and make sure everything resembles the following screenshot:</p>
<p><img src="/images/StringrSetupScreen.png" /></p>
</div>
</div>
<div id="using-stringr" class="section level1">
<h1>Using <code>stringr</code></h1>
<p>The package <code>stringr</code> is loaded as part of the <code>tidyverse</code> and contains a set of functions which are incredibly useful for manipulating text.
Often we’ll need to know these tricks as our sample names may have multiple genotypes or treatments embedded in them, and knowing how to get these pieces of information out can be very helpful.
Other times, we need to know how to correct typos longs the lines of sex being recorded as <code>male</code>, <code>female</code>, <code>M</code>, <code>m</code>, <code>f</code> or <code>F</code> all in the same document.
This type of thing happens more than you may realise, especially when dealing with large datasets that have a lot of manually entered values.
Alternatively we may need to remove a file suffix to make our plots look nicer.</p>
<p>The first thing we’ll need to do to get underway, is create a character vector that we’ll work with for this session.
Create new chunk called <code>hi</code> and create the vector <code>hi</code> as follows.</p>
<pre class="r"><code>hi &lt;- c(&quot;Hi Mum&quot;, &quot;Hi Mother&quot;)</code></pre>
<p>This is a simple character vector (of length 2) with two closely related phrases.
This will be short enough for us to work with today and see all of the results clearly.
In a real world context, <em>we often work with vectors with many thousands of entries.</em>
These are generally far too long to inspect one element at a time.</p>
<p>The package <code>stringr</code> has a whole series of functions, many of which start with <code>str_</code>.
From here on, we strongly advise to demonstrate each function within it’s own chunk, and for you to make notes in your R Markdown document that help <strong>you</strong> understand what we’re doing.
For nearly all of the following examples, we won’t actually create a new object, but will just demonstrate the output of each function, which should appear as R output when you compile your document.
Importantly, for the first set of functions we look at, we pass the function a character vector of length 2, and we will return a character vector of length 2.
There are a few exceptions later on though.</p>
<div id="changing-case" class="section level2">
<h2>Changing Case</h2>
<p>We can very easily change the case of our vector, and this may be of help when our collaborators have given us same strange combination of M/m/F/f encoding for the sex of our samples.
The main functions are <code>str_to_lower()</code>, <code>str_to_upper()</code> and <code>str_to_title</code>, with final helpful function being <code>str_to_sentence()</code>.
All of these take one main argument, called <code>string</code> in the function.
When we call a function in R, we can name these arguments explicitly, or if we pass everything in order we don’t need to name these.
The first two lines of code below are essentially identical.</p>
<pre class="r"><code>str_to_lower(string = hi)
str_to_lower(hi)</code></pre>
<p>Notice that because the first argument expected by <code>str_to_lower()</code> is called string, we can name it, or just pass our character vector to the function in the first position.
For the remaining three functions in this set, we will omit the argument name for convenience, although including it is better practice.</p>
<pre class="r"><code>str_to_upper(hi)
str_to_title(hi)
str_to_sentence(hi)</code></pre>
<p>These are quite well named functions as the name makes it clear what the output will be.
This is not always the case with functions, so make sure you describe what each one does.</p>
</div>
<div id="removing-unwanted-text" class="section level2">
<h2>Removing Unwanted Text</h2>
<p>Often we have to remove unwanted text like file suffixes and directory names, and <code>str_remove_all()</code> makes this easy.
There are two arguments we need to provide to this function.
The first is called <code>string</code>, whilst the second argument is called <code>pattern</code>.
Now, we need to specify two arguments.
We can either name them explicitly, or just pass all of the values in the correct position.</p>
<pre class="r"><code>str_remove_all(string = hi, pattern = &quot;M&quot;)
str_remove_all(hi, &quot;M&quot;)</code></pre>
<div id="regular-expression-syntax" class="section level3">
<h3>Regular Expression Syntax</h3>
<p>In <code>stringr</code>, syntax is based on <strong>regular expressions</strong>, so as well as specifying exact patterns to match, we can provide a <em>set of alternative values</em>.
In the following, we’ll remove either an upper or lower case <code>m</code> by providing a set of alternative characters within the square brackets, i.e. <code>"[Mm]"</code>.
We’ll follow that by removing all lower-case vowels.</p>
<pre class="r"><code>str_remove_all(hi, &quot;[Mm]&quot;)
str_remove_all(hi, &quot;[aeiou]&quot;)</code></pre>
<p>We can also set ranges of values to remove, such as all <em>upper-case</em> letters, or just those between <code>a</code> and <code>i</code> in the alphabet.</p>
<pre class="r"><code>str_remove_all(hi, &quot;[A-Z]&quot;)
str_remove_all(hi, &quot;[a-i]&quot;)</code></pre>
<p><strong>NB:</strong> There is an alternative function <code>str_remove()</code> provided by <code>stringr</code> which will only remove the first match to the supplied pattern.
This is mostly not the function you’ll be after, but you may choose it by accident at some point, then wonder what went wrong.</p>
<div id="wild-cards" class="section level4">
<h4>Wild Cards</h4>
<p>Because syntax is based on <strong>regular expressions</strong>, we can also <strong>set a wild-card character by using the <code>.</code> symbol.</strong>
For those familiar with regular expressions, this will be old news, but for those who are not familiar with <code>regexp</code> syntax this may be a new way of working with text.
Some of you may also be familiar with using the <code>*</code> symbol as a plain-text wild-card, but importantly the <code>*</code> symbol doesn’t work in that manner here and actually <em>has a completely different meaning</em>.</p>
<pre class="r"><code>str_remove_all(hi, &quot;Mu&quot;)
str_remove_all(hi, &quot;M.&quot;)</code></pre>
</div>
<div id="extending-matches" class="section level4">
<h4>Extending Matches</h4>
<p>In this last example, we’ve removed the upper case <code>M</code> and any single character that directly follows it.
We could also remove <strong>any number of following characters</strong> by adding a <code>+</code> symbol after the <code>.</code>, which is interpreted as <em>match anything (.) one or more times (+)</em></p>
<pre class="r"><code>str_remove_all(hi, &quot;M.+&quot;)</code></pre>
<p>Or we can specify the <em>exact number of matches</em>.
In this example, we’re matching anything (<code>.</code>) for exactly <code>2</code> characters.</p>
<pre class="r"><code>str_remove_all(hi, &quot;M.{2}&quot;)</code></pre>
</div>
<div id="anchoring-matches" class="section level4">
<h4>Anchoring Matches</h4>
<p>We can also anchor the match to be the beginning or end of a string.
Placing the <code>^</code> character at the beginning of a pattern means that the match must occur at the beginning of the string.</p>
<pre class="r"><code>str_remove_all(hi, &quot;[Hh]&quot;)
str_remove_all(hi, &quot;^[Hh]&quot;)</code></pre>
<p>The dollar symbol (<code>$</code>) performs this exact function for matches at the end of a string, and can be placed at the end f the pattern.</p>
<pre class="r"><code>str_remove_all(hi, &quot;[Mm]&quot;)
str_remove_all(hi, &quot;[Mm]$&quot;)</code></pre>
</div>
</div>
<div id="extracting-patterns" class="section level3">
<h3>Extracting Patterns</h3>
<p>As well as just removing sections of a text string,there are various methods for reaching into a text string and grabbing the patterns we need.
The first of these is <code>str_extract()</code> which also takes the two arguments <code>string</code> and <code>pattern</code>.
If we search for a pattern that doesn’t exist, <code>str_extract()</code> will return a missing value (<code>NA</code>).</p>
<pre class="r"><code>str_extract(hi, &quot;Mu&quot;)
str_extract(hi, &quot;M.+&quot;)</code></pre>
<p>Notice how the patterns behave in the exact same manner as we saw with <code>str_replace_all()</code>, by using the <code>regex</code> syntax.
We can also use exact positions within a text string using <code>str_sub()</code>, with the arguments <code>string</code>, <code>start</code> and <code>end</code>.
Notice that naming the <code>start</code> and <code>end</code> arguments explicitly is really helpful here as when you read this back in 2 years time, you’ll immediately understand what the numbers <code>4</code> and <code>5</code> represent.</p>
<pre class="r"><code>str_sub(hi, start = 4, end = 5)</code></pre>
</div>
</div>
<div id="replacing-text" class="section level2">
<h2>Replacing Text</h2>
<p>Sometimes, we don’t need to just find or extract one simple pattern, but we need to perform more complex manipulations.
The function <code>str_replace()</code> allows us to specify the arguments <code>string</code> &amp; <code>pattern</code> as we’ve already seen, but also provide the third argument <code>replacement</code>.
Once again, the following two commands are identical, because we are providing the arguments in order.</p>
<pre class="r"><code>str_replace(string = hi, pattern = &quot;Hi&quot;, replacement = &quot;Hello&quot;)
str_replace(hi, &quot;Hi&quot;, &quot;Hello&quot;)</code></pre>
<p>We can also use our pattern matching tricks to replace either “Mum” or “Mother” with “Dad”.
<strong>Feel free to experiment with other patterns and replacements here.</strong></p>
<pre class="r"><code>str_replace(hi, &quot;M.+&quot;, &quot;Dad&quot;)</code></pre>
<p>As well as just using wild-cards, we can specify complete patterns as alternatives.
When searching using this technique, the alternative phrases must be provided within the round braces, and they are separated by the “|” symbol, which is commonly used to represent “OR”.</p>
<pre class="r"><code>str_replace(hi, &quot;(Mum|Mother)&quot;, &quot;Dad&quot;)</code></pre>
<div id="capturing-text" class="section level3">
<h3>Capturing Text</h3>
<p><code>str_replace()</code> also allows us to ‘capture’ a pattern within each text string, and incorporate it into the replacement.
<strong>To capture a pattern, we surround it in the round braces <code>()</code></strong>, as we did above.
<em>To return the pattern, we use the shortcut <code>\\1</code> which will return the</em> <strong>first</strong> <em>pattern we have captured.</em>
In the following, notice that <em>we’re matching white-space followed by “(M.+)”</em>, where the captured pattern is “M.+”.
In the replacement, we’re replacing the entire pattern (including the white-space) with a long string, but this replacement string <strong>includes the captured pattern</strong>.</p>
<pre class="r"><code>str_replace(
    string = hi, 
    pattern = &quot; (M.+)&quot;, 
    replacement = &quot;! We captured and replaced the pattern \\1.&quot;
)</code></pre>
<p>We can also capture multiple patterns, and return them in any order we choose.
In the following:</p>
<ul>
<li>our first capture will be “Hi”</li>
<li>then we <em>don’t capture the white-space</em>, but</li>
<li>then we capture the pattern “M.+” as we did before.</li>
</ul>
<p>In our replacement, we’re returning them in the opposite order that we captured them in, and we’re also including some exclamation marks and additional white-space.</p>
<pre class="r"><code>str_replace(hi, &quot;(Hi) (M.+)&quot;, &quot;\\2! \\1!&quot;)</code></pre>
<p>Just like <code>str_remove()</code> and <code>str_remove_all()</code>, there are two versions of <code>str_replace()</code>.
The first will only replace the first match to the pattern, whilst <code>str_replace_all()</code> will replace all matches to the pattern.
Depending on what operation you’re needing to perform, either may be suitable.</p>
<pre class="r"><code>str_replace(hi, &quot;[Mm]&quot;, &quot;b&quot;)
str_replace_all(hi, &quot;[Mm]&quot;, &quot;b&quot;)</code></pre>
</div>
</div>
<div id="a-few-more-handy-functions" class="section level2">
<h2>A few more handy functions</h2>
<p>The above functions are probably the “big guns” of <code>stringr</code>, however there are a few more very useful things we can do to clean up our data.
If we wish to ensure that our text strings <em>are all the same length</em>, we can pad them with any character we choose, using <code>str_pad()</code>.
This takes the arguments <code>string</code>, <code>width</code>, <code>side</code> and <code>pad</code> as the four arguments.
In the first example, we’re setting our new strings to be exactly 10 characters wide, and we’re padding on the right with exclamation marks.
Note again, that explicitly naming the arguments here helps us understand exactly what we’re doing with the function.</p>
<pre class="r"><code>str_pad(hi, width = 10, side = &quot;right&quot;, pad = &quot;!&quot;)</code></pre>
<p>Another common use for something like this would be to pad numbers to ensure we have the same number of digits.
If numbers are represented as characters, most sorting algorithms sort them alpha-numerically instead of numerically.
We often see strange ordering like <em>1</em>, <em>10</em>, <em>2</em>, <em>3</em>, <em>4</em>, <em>5</em>, <em>6</em>, <em>7</em>, <em>8</em> and <em>9</em> instead of the more reasonable <em>1</em>, <em>2</em>, <em>3</em>, <em>4</em>, <em>5</em>, <em>6</em>, <em>7</em>, <em>8</em>, <em>9</em> and <em>10</em>.
In the next line, we’ll add zeroes in front of the numbers to ensure every number has two digits.
Once we’ve done this, alpha-numeric sorting and numeric sorting will give the same results.</p>
<pre class="r"><code>str_pad(1:10, width = 2, pad = &quot;0&quot;)</code></pre>
<p>Notice that we didn’t set the argument <code>side</code> here!
By default, this argument will be set to <code>side = "left"</code>, and we’ve relied on this value.
This means that <code>pad = "0"</code> will be provided in position 3 of the function, so <strong>must</strong> be explicitly named.
This also demonstrates why it can be helpful to explicitly name arguments.</p>
<p>Sometimes we can end up with ridiculously long text strings, particularly when dealing with gene-set enrichment analyses, so we can use <code>str_trunc()</code> to truncate these.
By default, the last 3 characters of a truncated string will be given as the ellipsis (<code>...</code>) to indicate the text has been shortened.</p>
<pre class="r"><code>str_trunc(hi, width = 6)</code></pre>
<p>Finally, we often see text strings which have excessive white-space, so we can remove this using <code>str_trim()</code>.
This will remove leading or trailing white-spaces from the text.</p>
<pre class="r"><code>str_trim(&quot;   Hi!&quot;)</code></pre>
</div>
<div id="approaches-that-return-different-structures" class="section level2">
<h2>Approaches That Return Different Structures</h2>
<p>In all of the above, we provided a character vector of length 2 and we obtained a character vector of length 2 as our output.
(<code>NA</code> technically still counts as a character.)
There are multiple other functions which exist that return output in different forms</p>
<div id="finding-matching-text" class="section level3">
<h3>Finding Matching Text</h3>
<p>The first of these might be to perform a logical test for the presence of a pattern within our text strings.
<code>str_detect()</code> again takes the two arguments <code>string</code> and <code>pattern</code>, with a third argument called <code>negate</code> that defaults to <code>FALSE</code>.
If we set this to <code>TRUE</code>, we will invert our results, which is often referred to as negating a logical search.
In both cases, we no longer return a character vector, but return the logical values <code>TRUE</code> and <code>FALSE</code>.</p>
<pre class="r"><code>str_detect(hi, &quot;Mum&quot;)
str_detect(hi, &quot;Mum&quot;, negate = TRUE)</code></pre>
<p>These functions really come into their own when we’re dealing with spreadsheet-like structures (known as data frames) and we wish to perform some kind of filtering on our values, as we would with Auto-Filter in Excel.</p>
<p>Sometimes it can be convenient to look in specific positions within our text and the two functions <code>str_starts()</code> and <code>str_ends()</code> check to see if a string starts or ends with a specific pattern.
Both of these also take the argument <code>negate</code>, which we’ll leave as the default (<code>negate = FALSE</code>).</p>
<pre class="r"><code>str_starts(hi, &quot;Hi&quot;)
str_ends(hi, &quot;m&quot;)</code></pre>
<p>We can also subset our initial character vector, so that only the elements which match our search pattern are returned.
Here, we provide a character vector of length 2 and initially return a character vector of length 1.
By incorporating <code>regex</code> wildcards, we can then return any elements that contains “M.”.</p>
<pre class="r"><code>str_subset(hi, &quot;Mum&quot;)
str_subset(hi, &quot;M.&quot;)</code></pre>
<p>A final function (<code>str_view_all()</code>) returns a completely different output.
This matches the specified pattern and opens the results in the <strong>Viewer</strong> pane, which we haven’t used until now.
This can be incredibly helpful if you’re trying to build a complex search pattern and want to check where it’s matching.</p>
<pre class="r"><code>str_view_all(hi, &quot;M.+&quot;)</code></pre>
</div>
<div id="counting-letters" class="section level3">
<h3>Counting letters</h3>
<p>Sometimes, it can be helpful to obtain information about the content of our text strings, such as their overall length, or the number of times a specific letter or pattern appear.
I’m sure you’ll immediately realise this can be very useful if wanting to assess the nucleotide content of a DNA/RNA sequence.
In NextGen Sequencing experiments, the GC content of a sequence is a known factor that biases our ability to sequence a DNA fragment.
In all of these, we’ll provide our input as a character vector with length 2, but will obtain an integer vector of the same length as the output.</p>
<pre class="r"><code>str_length(hi)
str_count(hi, &quot;[Hh]&quot;)
str_count(&quot;AGCTGCGCGATTTAGC&quot;, &quot;[GC]&quot;)</code></pre>
</div>
<div id="collapsing-and-joining-text" class="section level3">
<h3>Collapsing and Joining Text</h3>
<p>Sometimes, we need to condense multiple text strings into a single string, and we can use <code>str_flatten</code> for this.</p>
<pre class="r"><code>str_flatten(hi, collapse = &quot;, &quot;)</code></pre>
<p>However, there are two <code>base</code> functions <code>paste()</code> and <code>paste0()</code> that are just as helpful here, and probably a little more flexible.</p>
<pre class="r"><code>paste(hi, collapse = &quot;, &quot;)</code></pre>
<p>In addition to performing the above concatenation, we more commonly use the argument <code>sep</code> within the function <code>paste()</code> to join additional text to a string.
In the following, we’re pasting an additional phrase to each of our initial vector elements, and specifying the separator between the phrases to be <code>", "</code>.</p>
<pre class="r"><code>paste(hi, &quot;I hope you&#39;re well.&quot;, sep = &quot;, &quot;)</code></pre>
<p>The function <code>paste0()</code> is a simple wrapper to <code>paste()</code> but with <code>sep = ""</code> as the default.</p>
<pre class="r"><code>paste0(hi, &quot;!&quot;)</code></pre>
</div>
</div>
<div id="separating-text" class="section level2">
<h2>Separating Text</h2>
<p>Finally, a common operation is to separate a single text string into multiple text strings based on a specific character, or set of characters.
The function that gives us the most convenient output for this is <code>str_split_fixed()</code>, where we provide the arguments <code>string</code>, <code>pattern</code> and <code>n</code>, with the final argument controlling how many strings to obtain from the initial string.
In the following, we’re splitting our text based on white-space, and ensuring that each string is only split into 2 new strings.
This provides output in a structure known as a <code>matrix</code>, which we’ll explore further in the course.</p>
<pre class="r"><code>str_split_fixed(hi, &quot; &quot;, 2)</code></pre>
<p>In general, when performing this type of operation, we’re looking for something specific and we’ll know what type of output we need.
There is a slightly more flexible function <code>str_split()</code>, however the output format from <code>str_split()</code> is a <code>list</code> so a working knowledge of list objects in R is really essential for using this function.</p>
<pre class="r"><code>str_split(hi, &quot; &quot;)</code></pre>
</div>
</div>
<div id="using-this-in-context" class="section level1">
<h1>Using This In Context</h1>
<div id="loading-the-counts" class="section level2">
<h2>Loading The Counts</h2>
<p>The above was a fairly detailed introduction to manipulating text, but to really understand things we should perform these operations in a contact that we’re familiar with.
Let’s load the data object that we prepared last week and use our new tricks on the sample names.</p>
<p>If you can recall, we loaded this object using the following code.</p>
<pre class="r"><code>fl &lt;- here::here(&quot;data/counts.out&quot;)
counts &lt;- read_tsv(fl, comment = &quot;#&quot;)</code></pre>
<p>As we discussed last week, this is the output from <code>featureCounts</code> and we have the following columns.</p>
<ol style="list-style-type: decimal">
<li><code>Geneid</code>: This is clearly the gene identifier, here we have Ensembl</li>
<li><code>Chr</code>: The chromosome, with one value for each exon</li>
<li><code>Start</code>: The start positions for each exon</li>
<li><code>End</code>: The end positions for each exon</li>
<li><code>Strand</code>: The strand of each exon</li>
<li><code>Length</code>: The combined length of all exons combined</li>
<li>The first column with actual counts from an RNA-Seq experiment</li>
</ol>
<p>If setting this up for an RNA-Seq analysis using <code>edgeR</code> we would need to form a numeric matrix with</p>
<ul>
<li>Gene IDs as row names</li>
<li>Sample IDs as column names</li>
</ul>
<p>As this manipulation is not the focus of the current session, my strategy for doing this might be as follows.</p>
<pre class="r"><code>counts &lt;- counts %&gt;%
    dplyr::select(Geneid, ends_with(&quot;bam&quot;)) %&gt;%
    rename_all(basename) %&gt;%
    rename_all(str_remove_all, pattern = &quot;.trimmed.+&quot;) %&gt;%
    column_to_rownames(&quot;Geneid&quot;) %&gt;%
    as.matrix()</code></pre>
<p>The steps taken here were all chained together using the <code>magrittr</code> and consisted of</p>
<ol style="list-style-type: decimal">
<li>Select only the relevant columns. Notice I called by name not position. This is very important as <strong>if you run <code>featureCounts</code> on the same set of bam files twice, the column order will not be the same in both files</strong></li>
<li>Removed any directory prefix from all column names using the function <code>basename()</code></li>
<li>Use <code>str_replace_all()</code> to remove <code>.trimmedAligned.sortedByCoord.out.bam</code> from the end of each sample</li>
<li>Shifted the <code>Geneid</code> column to be rownames</li>
<li>Converted into a <code>matrix</code></li>
</ol>
<p>Alternatively, if we wish to edit as we parse the data into R.
The following approach is an alternative that ensures we never have the same object in two forms within our workspace.</p>
<pre class="r"><code>counts &lt;- read_tsv(fl, comment = &quot;#&quot;) %&gt;%
    dplyr::select(Geneid, ends_with(&quot;bam&quot;)) %&gt;%
    rename_all(basename) %&gt;%    
    rename_all(str_remove_all, pattern = &quot;.trimmed.+&quot;) %&gt;%
    column_to_rownames(&quot;Geneid&quot;) %&gt;%
    as.matrix()  </code></pre>
</div>
<div id="creating-a-metadata-object" class="section level2">
<h2>Creating a Metadata Object</h2>
<p>Sample names often contain the key information we need and in R, we can obtain this information fairly easily using our new skills.
First we can start by forming a <code>tibble</code> with a single column.
This gives us a chance to see where we are before we go any further.</p>
<pre class="r"><code>tibble(
    file = colnames(counts)
)</code></pre>
<p>There are two pieces of information here which are important:</p>
<ol style="list-style-type: decimal">
<li>The SRA Identifier</li>
<li>The tissue, annotated as either <code>cbc</code> or <code>skm</code> for cerebral cortex or skeletal muscle respectively.</li>
</ol>
<p>Let’s try to get these into separate columns, starting with the SRA ID</p>
<pre class="r"><code>tibble(
    file = colnames(counts)
) %&gt;%
    mutate(
        sra_id = str_extract(file, &quot;SRR[0-9]+&quot;)
    )</code></pre>
<p>Now let’s extract the tissue</p>
<pre class="r"><code>tibble(
    file = colnames(counts)
) %&gt;%
    mutate(
        sra_id = str_extract(file, &quot;SRR[0-9]+&quot;),
        tissue = str_extract(file, &quot;(cbc|skm)&quot;)
    )</code></pre>
<p>An important perspective here is that the SRA id is a text string which identifies a sample.
In contrast, the tissue is a categorical variable that we will include in our statistical model.
By default, <code>R</code> will convert any character columns to factors during analysis, and will always set these in alphabetic order.
Here, the default would be <code>cbc</code> as the baseline (or reference) with <code>skm</code> as the second level.
A general principle is that we wish to specify our baseline (or control) group as the first (i.e. reference) factor level.
This isn’t really important for this dataset, but if you had DHT and Veh, you’d want to set Veh as the reference level.
Relying on R to do this in alphabetic order may not always be wise.</p>
<p>Let’s manually specify the factor levels.</p>
<pre class="r"><code>tibble(
    file = colnames(counts)
) %&gt;%
    mutate(
        sra_id = str_extract(file, &quot;SRR[0-9]+&quot;),
        tissue = str_extract(file, &quot;(cbc|skm)&quot;),
        tissue = factor(tissue, levels = c(&quot;cbc&quot;, &quot;skm&quot;))
    )</code></pre>
<p>Notice that the column now contains a factor whilst the first two columns are printed as characters.
This will not only impact the interpretation of our statistical model, but can also impact the order values are shown in when plotting.</p>
<p>The <code>tidyverse</code> package <code>forcats</code> has a number of useful function for working with factors, with a possible alternative here being <code>fct_inorder()</code>.
I personally like to be explicit though.
If a file was somehow included without <code>cbc</code> or <code>skm</code> an <code>NA</code> would result and this would (hopefully) alert me that the data had taken an unexpected form.</p>
<p>Maybe we can add a better description of the tissue for our collaborators to understand the data.</p>
<pre class="r"><code>tibble(
    file = colnames(counts)
) %&gt;%
    mutate(
        sra_id = str_extract(file, &quot;SRR[0-9]+&quot;),
        tissue = str_extract(file, &quot;(cbc|skm)&quot;),
        tissue = factor(tissue, levels = c(&quot;cbc&quot;, &quot;skm&quot;)),
        description = case_when(
            str_detect(file, &quot;cbc&quot;) ~ &quot;Cerebral Cortex&quot;,
            str_detect(file, &quot;skm&quot;) ~ &quot;Skeletal Muscle&quot;
        )
    )</code></pre>
<p>This looks pretty good to me, so at this point I would save this as a metadata object.</p>
<pre class="r"><code>samples &lt;- tibble(
    file = colnames(counts)
) %&gt;%
    mutate(
        sra_id = str_extract(file, &quot;SRR[0-9]+&quot;),
        tissue = str_extract(file, &quot;(cbc|skm)&quot;),
        tissue = factor(tissue, levels = c(&quot;cbc&quot;, &quot;skm&quot;)),
        description = case_when(
            str_detect(file, &quot;cbc&quot;) ~ &quot;Cerebral Cortex&quot;,
            str_detect(file, &quot;skm&quot;) ~ &quot;Skeletal Muscle&quot;
        )
    )</code></pre>
<p>If we’re adventurous we might also like to add the library sizes, and although this isn’t text manipulation, it’s good to see here.</p>
<pre class="r"><code>samples &lt;- tibble(
    file = colnames(counts)
) %&gt;%
    mutate(
        sra_id = str_extract(file, &quot;SRR[0-9]+&quot;),
        tissue = str_extract(file, &quot;(cbc|skm)&quot;),
        tissue = factor(tissue, levels = c(&quot;cbc&quot;, &quot;skm&quot;)),
        description = case_when(
            str_detect(file, &quot;cbc&quot;) ~ &quot;Cerebral Cortex&quot;,
            str_detect(file, &quot;skm&quot;) ~ &quot;Skeletal Muscle&quot;
        ),
        library_size = colSums(counts)[file]
    )</code></pre>
<p>Now that we have our metadata, I’ll often summarise this into a table.
The package <code>pander</code> is extremely useful for this, so please add <code>library(pander)</code> to your <code>packages</code> chunk <em>and make sure you execute the chunk</em>.</p>
<pre class="r"><code>library(tidyverse)
library(pander)</code></pre>
<p>Then add the following.</p>
<pre class="r"><code>samples %&gt;%
    group_by(description) %&gt;%
    summarise(
        n = n(),
        `Ave. Library Size` = mean(library_size)
    ) %&gt;%
    rename_all(str_to_title) %&gt;%
    pander(
        caption = &quot;Summary of RNA-Seq Counts&quot;,
        big.mark = &quot;,&quot;
    )</code></pre>
<p>Notice that we’ve used <code>str_to_title()</code> inside the call to <code>rename_all()</code> to make our table look nice, but without changing our data object.</p>
</div>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<p>In the above you may have noticed that nothing was ever called by position using <code>x[1:5]</code> or something similar.
This helps build good practice.
If we call by position (e.g. <code>x[1:5]</code>) we create two problems:</p>
<ol style="list-style-type: decimal">
<li>If the data structure changes our analysis may break, <strong>or worse</strong>, may complete without us being aware of the changes producing invalid results</li>
<li>When we revisit our code in the future, we won’t know what’s in any object when selecting by position. If we select columns 1:5, we have to remember what’s in those columns and check that everything is correct.</li>
</ol>
<p>When forming the counts object, I used <code>dplyr::select()</code> and when reading that back, it’s very clear what we did.</p>
<pre class="r"><code>dplyr::select(counts, Geneid, ends_with(&quot;bam&quot;))</code></pre>
<p>is much easier to interpret than</p>
<pre class="r"><code>counts[,c(1, 7:14)]</code></pre>
<p>When we defined the metadata, we pulled all values directly from the <code>counts</code> object, ensuring that if the order changed our code will still produce the object in the correct structure.</p>
<p>The <em>old-school</em> method of defining the tissue might have been</p>
<pre class="r"><code>rep(c(&quot;cbc&quot;, &quot;skm&quot;), times = 4)</code></pre>
<p>This is not robust to the order changing, or any samples being added/removed.
Using <code>str_extract()</code> is incredibly simple, but makes for code which is far more robust to changes in your data structure.
As mentioned, <code>featureCounts</code> will produce columns in a different order every time it runs on the same set of bam files.
Building code in the way we have done, protects us from this kind of problem.</p>
</div>

        </div>
        <div class="post-footer">
            <div class="info">
                
                <span class="separator"><a class="tag" href="/tags/tidyverse/">tidyverse</a><a class="tag" href="/tags/stringr/">stringr</a><a class="tag" href="/tags/r-markdown/">R Markdown</a></span>

            </div>
        </div>

        
            
        
    </div>


        </div>
    </div>
</div>

<script type="text/javascript"
        src="/js/jquery.min.86b1e8f819ee2d9099a783e50b49dff24282545fc40773861f9126b921532e4c.js"
        integrity="sha256-hrHo&#43;BnuLZCZp4PlC0nf8kKCVF/EB3OGH5EmuSFTLkw="
        crossorigin="anonymous"></script>




<script type="text/javascript"
        src="/js/bundle.min.0f9c74cb78f13d1f15f33daff4037c70354f98acfbb97a6f61708966675c3cae.js"
        integrity="sha256-D5x0y3jxPR8V8z2v9AN8cDVPmKz7uXpvYXCJZmdcPK4="
        crossorigin="anonymous"></script>

<script type="text/javascript"
        src="/js/medium-zoom.min.92f21c856129f84aeb719459b3e6ac621a3032fd7b180a18c04e1d12083f8aba.js"
        integrity="sha256-kvIchWEp&#43;ErrcZRZs&#43;asYhowMv17GAoYwE4dEgg/iro="
        crossorigin="anonymous"></script>
</body>

</html>
